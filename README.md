
Программа "Электронная таблица."
================================

Итак, перед вами некоторый демонстрационный вариант программы того типа, который принято называть электронной
таблицей. Понятно, что в современном мире явно не наблюдается недостатка в электронных таблицах, поэтому основной
целью разработки данной программы была не практическая, а учебно-исследовательская. Точнее, она была написана
для изучения процесса работы с генератором синтаксических анализаторов ANTLR, порождённые которым файлы
в значительной мере и лежат в основе вычислительного ядра предлагаемой таблицы.

Весь проект разделён на две части - *фронтенд* и *бекэнд*. Обе части обладают существенной независимостью друг
от друга и объединены только через интерфейс, предоставляемый бекэндовой частью комплекса. Бекэнд может
соединяться и с любой другой сторонней программой, которая будет соблюдать соглашение об интерфейсе, описанное
ниже.

Интерфейс *бекэнда* электронной таблицы.
--------------------------------------

С точки зрения внешнего интерфейса электронная таблица представляет собой объект класса Sheet, и работа с ней
выполняется вызовом его публичных методов. Сокращённое иллюстративное объявление класса Sheet с перечислением
его доступных публичных методов выглядит так:

    class Sheet
    {
    public:
    
        void SetCell(Position pos, string text);
        void InsertEmptyCell(Position pos);
    
        CellInterface* GetCell(Position pos);
    
        void ClearCell(Position pos);
    
        Size GetPrintableSize();
    
        void PrintValues(ostream& output);
        void PrintTexts(ostream& output);
    };

Электронная таблица поддерживает двойную согласованную систему адресации. При обращении к её ячейкам через методы
класса Sheet адресация целевой (той, для которой следует выполнить операцию) ячейки таблицы осуществляется с помощью
вспомогательного типа - структуры Position. Эта структура содержит публичные целочисленные поля строки и столбца,
в которых находится целевая ячейка таблицы, а также несколько вспомогательных методов для работы с ними. Объекты
класса также возможно сравнивать между собой на "меньше" и "равно".

    struct Position
    {
        int row = 0; // Строка ячейки, индексация с нуля.
        int col = 0; // Столбец ячейки, индексация с нуля.
    
        bool IsValid();
        string ToString();
    
        static Position FromString(string_view str);
    
        static const int MAX_ROWS;
        static const int MAX_COLS;
        static const Position NONE;
    };

Адресация же ячеек изнутри таблицы, то есть со стороны самих ячеек, которые могут ссылаться на другие ячейки той же
таблицы, выполняется по специальной буквенно-цифровой системе адресов (впрочем, такая система общепринята для электронных
таблиц). В этом случае адрес ячейки состоит из слитно написанного буквенного адреса столбца и цифрового адреса строки.
Методы ToString и FromString класса Position позволяют транслировать одно представление адреса в другое.

Методы класса Sheet являются вполне самодокументируемыми и выполняемые ими операции вполне очевидны. Поэтому ограничимся
здесь лишь краткими комментариями относительно них.

Метод SetCell(Position pos, string text) устанавливает новое значение ячейки с адресом pos с соответствии со значением
строки text. В зависимости от вида строки-аргумента ячейка может принять непосредственное строковое или числовое значение,
либо получить значение в виде формулы - математического выражения, допускающего вычисление до числа с плавающей точкой.
Допускаемое математическое оснащение формул довольно скромное: на данный момент они допускают лишь четыре арифметических
действия, операндами которых могут быть числами (в нотации с фиксированной и плавающей точкой) или ссылками на другие
ячейки таблицы. Требуемые ячейки указываются с помощью описанной выше буквенно-цифровой нотации. Формула должна начинаться
со знака '=', причём перед ним не должно быть никаких иных символов, включая пробельных. Все другие строковые выражения,
первый символ которых отличается от знака '=', полагаются непосредственными значениями.

Если требуется ввести непосредственное значение, начинающееся со знака равенства '=', то его можно заэкранировать символом
апострофа '\''. Выражение будет атрибутировано как непосредственное значение, сам же этот символ в него не войдет. Если же
в начале требуемой строки должен быть сам апостроф, то его в таком случае следует удвоить.

В таблице не допускаются циклические ссылки между ячейками. В случае обнаружения таковой при исполнении метода SetCell
значение ячейки не изменится, и будет выброшено исключение класса CircularDependencyException.

Метод InsertEmptyCell(Position pos) создаёт пустую ячейку (или опустошает уже существующую) по адресу pos.
Метод ClearCell(Position pos) уничтожает уже существующую ячейку с адресом pos.

Метод GetCell(Position pos) возвращает значение ячейки. Он возвращает его в виде указателя на объект класса CellInterface,
используя методы которого, можно получить всю необходимую информацию о состоянии и содержимом ячейки. Описание данного класса
приведено ниже. Если ячейки в таблице не существует, будет возвращён нулевой указатель.

Метод GetPrintableSize() возвращает информацию о текущем размере таблицы. Возврат этой информации выполняется в виде переменной
класса Size, условное объявление которого также приведено ниже. Отметим, что этот класс поддерживает операцию сравнения на
равенство.

Методы PrintValues и PrintTexts носят служебный характер и выводят в поток output все ячейки из прямоугольной области её
текущего размера. Метод PrintValues направляет в поток рассчитанные значения ячеек, а метод PrintTexts - их исходные значения.

#### Иллюстративное сокращенное объявление структуры Size.

    struct Size
    {
        int rows = 0;
        int cols = 0;
    };


#### Иллюстративное сокращенное объявление класса CellInterface.

    class CellInterface
    {
    public:
        using Value = std::variant<std::string, double, FormulaError>;
    
        Value GetValue();
        string GetText();
        vector<Position> GetReferencedCells();
    };

Посредством методов класса CellInterface возможно получить некоторую информацию о ячейке. 

Прежде всего там определён вспомогательный тип Value для получения значения ячейки, которое может быть строкой,
числом (значением формулы) или ошибкой, возникшей при вычислении формулы.

Метод GetValue() возвращает видимое значение ячейки в виде значения типа Value. В случае текстовой ячейки это её
текст (без экранирующих символов). В случае формулы - числовое значение формулы или сообщение об ошибке.

Метод GetText() возвращает внутренний истинный текст ячейки. В случае текстовой ячейки это её текст (возможно,
содержащий экранирующие символы). В случае формулы - её выражение.

Наконец, метод GetReferencedCells() возвращает список ячеек, которые непосредственно задействованы в данной
формуле. Список отсортирован по возрастанию и не содержит повторяющихся адресов. В случае текстовой ячейки список пуст.
Метод имеет, в основном служебное значение и используется внутренне для отслеживания ссылок между ячейками.

Грамматика поддерживаемых формул описана в файле Formula.g4. На основе этого описания транслятор генератора
ANTLR создаёт файлы FormulaBaseListener, FormulaLexer, FormulaListener и FormulaParser.

Исключения и обработка ошибок.
------------------------------

Основным способом сообщения об ошибках, которые могут возникать при вызове методов бекэнда, является выбрасывание различных
исключений. Их существует три класса: InvalidPositionException, FormulaException и CircularDependencyException.

Исключение первого класса - InvalidPositionException - возникает в том случае, если адрес целевой ячейки, определённой
аргументом какого-либо метода, является недопустимым (выходит за границы максимальных значений Position::MAX_ROWS и/или
Position::MAX_COLS). Аналогично, такое исключение может возникать, если сохраняемая в клетку таблицы формула содержит
ссылку на ячейку с недопустимым адресом.

Исключение класса FormulaException выбрасывается при любых синтаксических ошибках в формулах при сохранении такой неверной
формулы в ячейку.

Исключение класса CircularDependencyException может возникнуть при сохранении формулы в ячейку, если она содержит какие-либо
ссылки на прочие ячейки таким образом, что между ячейками таблицы образуются циклические зависимости. Существование
циклических зависимостей в таблице считается недопустимым.

Во всех случаях программа обеспечивает строгую гарантию безопасности исключений, и при выбрасывании любого исключения
состояние таблицы сохраняется в виде, предшествующем вызову ошибочного метода.

*Фронтенд* и практическая реализация электронной таблицы.
-------------------------------------------------------

В качестве иллюстрации работы с описываемым бекэндом в проект входит небольшой демонстрационный фронтенд, реализующий
элементарную электронную таблицу на основе предлагаемого бекэнда. Фронтенд реализован на основе интерфейсного каркаса
wxWidgets в среде CodeBlocks с использованием интерактивного построителя форм wxSmith. Файл проекта CodeBlocks и рабочий
файл wxSmith также приложены к проекту.

Эта оболочка служит чисто демонстративным целям, использовать её практически вряд ли возможно, так как в существующем
состоянии она не поддерживает даже самых необходимых операций. Но всё же, если кто-то попробует это сделать, вряд ли это
вызовет какие-либо затруднения, так как её интерфейс является вполне самодокументируемым. Все доступные операции выполняются
через основное меню, редактирование содержимого ячеек осуществляется непосредственно в полях экранной сетки.
Работа с блоками и выделениями пока не поддерживается.

Предстоящие доработки и планы на будущее.
-----------------------------------------

Основная сложность, препятствующая практическому применению описываемого бекэнда электронной таблицы, заключается в крайне
скудном математическом арсенале поддерживаемых формул. Только четыре арифметических действия и ссылки на другие одиночные
ячейки - и это пока всё. Так что в будущем доработка будет идти именно в этом направлении. Следует предусмотреть в качестве
отдельной сущности ссылку на *интервал ячеек*, а также ввести в математический ассортимент формул набор функций, необходимых
для эффективных табличных вычислений.

Компиляция проекта.
-------------------

Бекэнд может быть скомпилирован любым компилятором C++17. Для облегчения этой операции к проекту приложен сборочный cmake-скрипт.
Кроме того, среди файлов репозитория присутствует уже подготовленный проект для среды разработки CodeBlocks.

Из нестандартных внешних зависимостей - библиотека (точнее, целый инструментарий) ANTLR. Сам этот инструментарий состоит из двух
частей - кодогенератора и библиотеки периода исполнения (рантайм-модуля). Для компиляции проекта в исходном виде достаточно второго,
если же требуется поменять используемую формульную грамматику (Formula.g4), то потребуется и первый. Строки cmake-скрипта,
обеспечивающие перетрансляцию грамматики, закомментированы. Если эту операцию потребуется всё же выполнить, перед запуском cmake
их следует предварительно раскомментировать.

Скрипт и файл проекта ориентированы на вполне определённую версию ANTLR - ANTRL 4.7.2. Вероятно, подойдёт и ANTLR более новых
версий (хотя гарантий этого дать невозможно), но тогда скрипт тоже может потребовать некоторых исправлений. К проекту приложены
только необходимые для сборки самого проекта заголовки ANTRL-runtime, сам же рантайм-модуль ANTLR для вашей платформы желательно
скачать или, если это окажется невозможным, собрать его самостоятельно.

Кроме того, учтите, что кодогенератор ANTLR написан на Java, поэтому для его исполнения на целевой машине должна присутствовать
и быть настроенной исполнительная Java-среда, в которой будет он будет работать.

Готовая ANTLR рантайм-библиотека для MinGW (libantlr4-runtime.a, собрана в MinGW 11, Windows 7 32 bit) в двоичной форме, а также
Java-модуль кодогенератора (antlr-4.7.2-complete) входит в состав релиза этого проекта на GitHub, поэтому если ваше сборочное
окружение совпадает с описанным, то они могут вам пригодиться.

Демонстрационный фронтэнд электронной таблицы, помимо зависимости от бекэнда и, поэтому, от ANTLR, построен на основе оконного
каркаса wxWidgets, и, следовательно,  требует его наличия на машине, на которой будет выполняться сборка. Он также укомплектован
cmake-скриптом, проектом для CodeBlocks, и помимо того, конфигурационным файлом для интерактивного конструктора интерфейсов - wxSmith.
